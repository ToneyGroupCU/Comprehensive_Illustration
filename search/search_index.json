{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 This is a collection of code illustration of Toney Group . Free feel to contact me at zizh7255@colorado.edu . The design of this site is based on emptymalei/deep-learning from datumorphism . An example of what you can do here: \u00b6 A subsection \u00b6 LaTeX: $$ \\begin{equation} \\int _{\\text{x-ray}}^{\\text{Neutron}}\\text{Synchrotron}=??? \\end{equation} $$ Figure: Fig 1. This is a Synchrotron. Box: Neutron Neutron is Neutron X-ray X-ray is X-ray Synchrotron Synchrotron is Synchrotron Code Another Code import numpy as np import diffraction as diff import matplotlib.pyplot as plt import matplotlib.cm as cm import time as time from matplotlib.widgets import Button import scipy.io from matplotlib.widgets import RangeSlider import scipy.ndimage as ndimage Hello World !!! Contributors to Wikimedia projects. F-divergence. In: Wikipedia [Internet]. 17 Jul 2021 [cited 6 Sep 2021]. Available: https://en.wikipedia.org/wiki/F-divergence#Instances_of_f-divergences \u21a9 Nowozin S, Cseke B, Tomioka R. f-GAN: Training Generative Neural Samplers using Variational Divergence Minimization. arXiv [stat.ML]. 2016. Available: http://arxiv.org/abs/1606.00709 \u21a9 Contributors to Wikimedia projects. Convex conjugate. In: Wikipedia [Internet]. 20 Feb 2021 [cited 7 Sep 2021]. Available: https://en.wikipedia.org/wiki/Convex_conjugate \u21a9","title":"Home"},{"location":"#introduction","text":"This is a collection of code illustration of Toney Group . Free feel to contact me at zizh7255@colorado.edu . The design of this site is based on emptymalei/deep-learning from datumorphism .","title":"Introduction"},{"location":"#an-example-of-what-you-can-do-here","text":"","title":"An example of what you can do here:"},{"location":"#a-subsection","text":"LaTeX: $$ \\begin{equation} \\int _{\\text{x-ray}}^{\\text{Neutron}}\\text{Synchrotron}=??? \\end{equation} $$ Figure: Fig 1. This is a Synchrotron. Box: Neutron Neutron is Neutron X-ray X-ray is X-ray Synchrotron Synchrotron is Synchrotron Code Another Code import numpy as np import diffraction as diff import matplotlib.pyplot as plt import matplotlib.cm as cm import time as time from matplotlib.widgets import Button import scipy.io from matplotlib.widgets import RangeSlider import scipy.ndimage as ndimage Hello World !!! Contributors to Wikimedia projects. F-divergence. In: Wikipedia [Internet]. 17 Jul 2021 [cited 6 Sep 2021]. Available: https://en.wikipedia.org/wiki/F-divergence#Instances_of_f-divergences \u21a9 Nowozin S, Cseke B, Tomioka R. f-GAN: Training Generative Neural Samplers using Variational Divergence Minimization. arXiv [stat.ML]. 2016. Available: http://arxiv.org/abs/1606.00709 \u21a9 Contributors to Wikimedia projects. Convex conjugate. In: Wikipedia [Internet]. 20 Feb 2021 [cited 7 Sep 2021]. Available: https://en.wikipedia.org/wiki/Convex_conjugate \u21a9","title":"A subsection"},{"location":"tags/","text":"Tags \u00b6 Following is a list of relevant tags:","title":"Tags"},{"location":"tags/#tags","text":"Following is a list of relevant tags:","title":"Tags"},{"location":"GIWAXS/GIWAXS%20Index%20tool/","text":"GIWAXS index tool in Python \u00b6 Zihan Zhang ( zihan.zhang-1@colorado.edu ) & Keith White ( Keith.White@colorado.edu ) This is a python code to show the Bragg peak position and the Miller index on a 2D image (q \\(_{xy}\\) , q \\(_{z}\\) ). The program is based on GIWAXS simulation tool. You need to download diffraction.py to use the functions. The Bragg peak position is calculated using cif file. They are labeled as (h k l) on the image and the experiment data is used as background for comparison. Fig 1. This is the 2D image generated from the GIWAXS index tool. The background is simulation instead of experiment for illustration. The left row is not labeled because a cutoff of intensity is used to eliminate the peaks with low intensity. To plot the Miller index and their positions, you will need Bragg_peaks functions to calculate the Bragg peaks first and then call Mindexing function to make the 2D figure. The code and the workflow are attached below. Library Define the 'Mindexing' function Parameters Main import numpy as np import diffraction as diff import matplotlib.pyplot as plt import matplotlib.cm as cm import time as time from matplotlib.widgets import Button import scipy.io from matplotlib.widgets import RangeSlider import scipy.ndimage as ndimage import matplotlib.patheffects as path_effects def Mindexing ( data , colorbar , fsize , qrange , Mindexrange , I_miller , Cutoff_I , Mqxy , Mqz ): simuposi = np . zeros ([ 100 , 2 ]) isimuposi = 0 fig , ax = plt . subplots ( figsize = fsize ) plt . imshow ( data , interpolation = 'nearest' , cmap = cm . jet , origin = 'lower' , extent = qrange , vmax = colorbar * data . max (), vmin = data . min ()) plt . xlabel ( 'q$_ {xy} $(1/A)' , fontsize = 16 ) plt . ylabel ( 'q$_ {z} $(1/A)' , fontsize = 16 ) MaxI = 0 for h in Mindexrange : for k in Mindexrange : for l in Mindexrange : if Mqxy [ h , k , l ] < qxymax and Mqz [ h , k , l ] > qzmin and Mqz [ h , k , l ] < qzmax : MaxI = np . maximum ( I_miller [ h , k , l ], MaxI ) for h in Mindexrange : for k in Mindexrange : for l in Mindexrange : if Mqxy [ h , k , l ] < qxymax and Mqz [ h , k , l ] > qzmin and Mqz [ h , k , l ] < qzmax : if I_miller [ h , k , l ] > Cutoff_I * MaxI : plt . plot ( Mqxy [ h , k , l ], Mqz [ h , k , l ], 'ko' ) simuposi [ isimuposi , 0 ] = Mqxy [ h , k , l ] simuposi [ isimuposi , 1 ] = Mqz [ h , k , l ] isimuposi = isimuposi + 1 textstr = '(' + str ( h - hkl_dimension ) + ',' + str ( k - hkl_dimension ) + ',' + str ( - l + hkl_dimension ) + ')' millerplt = plt . text ( Mqxy [ h , k , l ] / ( 2 * qxymax ) + 0.5 , ( Mqz [ h , k , l ] - qzmin ) / ( qzmax - qzmin ), textstr , transform = ax . transAxes , fontsize = 10 , verticalalignment = 'top' , color = 'w' ) millerplt . set_path_effects ([ path_effects . Stroke ( linewidth = 3 , foreground = 'black' ), path_effects . Normal ()]) return simuposi data = II1 # This is the background/experiment data. data = np . log ( II1 + 1 ) colorbar = 0.9 fsize = ( 30 , 30 ) # You need a large figure to see the index. qrange = [ - qxymax , qxymax , qzmin , qzmax ] # This is the q range of your experiment data. Mindexrange = np . linspace ( 0 , hkl_dimension , hkl_dimension + 1 ) # Only the left side of the image is labeled Mindexrange = Mindexrange . astype ( 'int' ) Cutoff_I = 0.001 # Set the cutoff to eliminate the low intensity peaks dirr = '' filename = '' address = dirr + filename + '.vasp' thetax = np . pi / 2 * 0 thetay = np . pi / 2 * 0 hkl_dimension = 5 a1 , a2 , a3 , positions = diff . read_poscar ( address ) Bpeaks , Mqxy , Mqz , I_miller = diff . Bragg_peaks ( a1 , a2 , a3 , positions , thetax , thetay , hkl_dimension ) simuposi = Mindexing ( data , colorbar , fsize , qrange , Mindexrange , I_miller , Cutoff_I , Mqxy , Mqz ) print ( simuposi ) Workflow of this program: stateDiagram-v2 CIF --> POSCAR POSCAR: POSCAR POSCAR: Lattice Constants POSCAR: Atom position POSCAR --> Bragg Input1 --> Bragg Input1: Input Input1: (hkl) dimensions Input1: Rotation Bragg: Bragg peak Bragg: Bragg peak postitions in reciprocal space (3D) Bragg --> Mindexing Input2 --> Mindexing Input2: Input Input2: Experiment data Input2: Cutoff Intensity Input2: figure size Mindexing --> 2d 2d: 2d image display","title":"GIWAXS index tool"},{"location":"GIWAXS/GIWAXS%20Index%20tool/#giwaxs-index-tool-in-python","text":"Zihan Zhang ( zihan.zhang-1@colorado.edu ) & Keith White ( Keith.White@colorado.edu ) This is a python code to show the Bragg peak position and the Miller index on a 2D image (q \\(_{xy}\\) , q \\(_{z}\\) ). The program is based on GIWAXS simulation tool. You need to download diffraction.py to use the functions. The Bragg peak position is calculated using cif file. They are labeled as (h k l) on the image and the experiment data is used as background for comparison. Fig 1. This is the 2D image generated from the GIWAXS index tool. The background is simulation instead of experiment for illustration. The left row is not labeled because a cutoff of intensity is used to eliminate the peaks with low intensity. To plot the Miller index and their positions, you will need Bragg_peaks functions to calculate the Bragg peaks first and then call Mindexing function to make the 2D figure. The code and the workflow are attached below. Library Define the 'Mindexing' function Parameters Main import numpy as np import diffraction as diff import matplotlib.pyplot as plt import matplotlib.cm as cm import time as time from matplotlib.widgets import Button import scipy.io from matplotlib.widgets import RangeSlider import scipy.ndimage as ndimage import matplotlib.patheffects as path_effects def Mindexing ( data , colorbar , fsize , qrange , Mindexrange , I_miller , Cutoff_I , Mqxy , Mqz ): simuposi = np . zeros ([ 100 , 2 ]) isimuposi = 0 fig , ax = plt . subplots ( figsize = fsize ) plt . imshow ( data , interpolation = 'nearest' , cmap = cm . jet , origin = 'lower' , extent = qrange , vmax = colorbar * data . max (), vmin = data . min ()) plt . xlabel ( 'q$_ {xy} $(1/A)' , fontsize = 16 ) plt . ylabel ( 'q$_ {z} $(1/A)' , fontsize = 16 ) MaxI = 0 for h in Mindexrange : for k in Mindexrange : for l in Mindexrange : if Mqxy [ h , k , l ] < qxymax and Mqz [ h , k , l ] > qzmin and Mqz [ h , k , l ] < qzmax : MaxI = np . maximum ( I_miller [ h , k , l ], MaxI ) for h in Mindexrange : for k in Mindexrange : for l in Mindexrange : if Mqxy [ h , k , l ] < qxymax and Mqz [ h , k , l ] > qzmin and Mqz [ h , k , l ] < qzmax : if I_miller [ h , k , l ] > Cutoff_I * MaxI : plt . plot ( Mqxy [ h , k , l ], Mqz [ h , k , l ], 'ko' ) simuposi [ isimuposi , 0 ] = Mqxy [ h , k , l ] simuposi [ isimuposi , 1 ] = Mqz [ h , k , l ] isimuposi = isimuposi + 1 textstr = '(' + str ( h - hkl_dimension ) + ',' + str ( k - hkl_dimension ) + ',' + str ( - l + hkl_dimension ) + ')' millerplt = plt . text ( Mqxy [ h , k , l ] / ( 2 * qxymax ) + 0.5 , ( Mqz [ h , k , l ] - qzmin ) / ( qzmax - qzmin ), textstr , transform = ax . transAxes , fontsize = 10 , verticalalignment = 'top' , color = 'w' ) millerplt . set_path_effects ([ path_effects . Stroke ( linewidth = 3 , foreground = 'black' ), path_effects . Normal ()]) return simuposi data = II1 # This is the background/experiment data. data = np . log ( II1 + 1 ) colorbar = 0.9 fsize = ( 30 , 30 ) # You need a large figure to see the index. qrange = [ - qxymax , qxymax , qzmin , qzmax ] # This is the q range of your experiment data. Mindexrange = np . linspace ( 0 , hkl_dimension , hkl_dimension + 1 ) # Only the left side of the image is labeled Mindexrange = Mindexrange . astype ( 'int' ) Cutoff_I = 0.001 # Set the cutoff to eliminate the low intensity peaks dirr = '' filename = '' address = dirr + filename + '.vasp' thetax = np . pi / 2 * 0 thetay = np . pi / 2 * 0 hkl_dimension = 5 a1 , a2 , a3 , positions = diff . read_poscar ( address ) Bpeaks , Mqxy , Mqz , I_miller = diff . Bragg_peaks ( a1 , a2 , a3 , positions , thetax , thetay , hkl_dimension ) simuposi = Mindexing ( data , colorbar , fsize , qrange , Mindexrange , I_miller , Cutoff_I , Mqxy , Mqz ) print ( simuposi ) Workflow of this program: stateDiagram-v2 CIF --> POSCAR POSCAR: POSCAR POSCAR: Lattice Constants POSCAR: Atom position POSCAR --> Bragg Input1 --> Bragg Input1: Input Input1: (hkl) dimensions Input1: Rotation Bragg: Bragg peak Bragg: Bragg peak postitions in reciprocal space (3D) Bragg --> Mindexing Input2 --> Mindexing Input2: Input Input2: Experiment data Input2: Cutoff Intensity Input2: figure size Mindexing --> 2d 2d: 2d image display","title":"GIWAXS index tool in Python"},{"location":"GIWAXS/GIWAXS%20Simulation/","text":"GIWAXS Simulation tool in Python \u00b6 Zihan Zhang ( zihan.zhang-1@colorado.edu ) A program for 2D material diffraction simulation is introduced in this work. The sample is considered as crystallites with a Gaussian distribution in orientation in spherical coordinate (r, \\(\\theta\\) , \\(\\phi\\) ). The simulated diffraction pattern is in (q \\(_x\\) , q \\(_{xy}\\) ) plane which is designed to compare with WAXS(wide angle x-ray scattering) measurement. Thus Braggg peaks elongates in a ring pattern from their original positions in reciprocal space. Fig 1. (a) Crystal structure of 2D perovskite; (b) GIWAXS data of PPA; (c) GIWAXS simulation of PPA. Diffraction Intensity \u00b6 In reciprocal space, the Gaussian distribution in crystallites orientation results in a rotation for each Bragg peak. If we consider using an area detector to measure the diffraction intensity in q \\(_z\\) q \\(_{x}\\) plane. It is a summation of all Bragg peaks with each of them has the same Gaussian width( \\(\\sigma_\\theta\\) , \\(\\sigma_\\phi\\) ) centered in (q \\(_x\\) , q \\(_y\\) , q \\(_z\\) ): \\[ \\begin{equation} I(q_z,q_{x})=\\sum_{h,k,l}|\\sum_{i} f_i(\\mathbf{Q}) e^{i\\mathbf{Q}\\cdot\\mathbf{r}_n}|^2 e^{-\\frac{1}{2}\\frac{(\\theta^I-\\theta_0^B)^2}{\\sigma_\\theta^2}}e^{-\\frac{1}{2}\\frac{(\\phi^I-\\phi_0^B)^2}{\\sigma_\\phi^2}}e^{-\\frac{1}{2}\\frac{(q^I-q_0^B)^2}{\\sigma_q^2}} \\end{equation} \\] where ( \\(q^I\\) , \\(\\theta^I\\) , \\(\\phi^I\\) ) is the position of image plane(q \\(_x\\) , q \\(_z\\) ) in spherical coordinate. Fig 2. Spherical Coordinate \\[ \\begin{equation} q=\\sqrt{q_z^2+q_{x}^2},\\quad \\theta=\\frac{\\pi}{2}-\\arctan\\frac{q_z}{|q_{x}|}, \\quad \\phi= \\left\\{ \\begin{array}{cc} 0, \\quad x>0\\\\ \\pi,\\quad x<0 \\end{array} \\right. \\end{equation} \\] \\(\\mathbf{Q}\\) is the position of Bragg peaks and (hkl) is Miller index. \\(n\\) indicate the atoms in the unit cell and r \\(_n\\) is the real space position of \\(n\\) th atom in the unit cell. \\[ \\begin{equation} \\mathbf{Q}=h\\mathbf{b}_1+k\\mathbf{b}_2+l\\mathbf{b}_3 \\end{equation} \\] ( \\(q_0^B\\) , \\(\\theta_0^B\\) , \\(\\phi_0^B\\) ) is the position of Bragg peaks in reciprocal space converted to spherical coordinates: \\[ \\begin{equation} q_0^B=|\\mathbf{Q}|,\\quad\\theta_0^B=\\arctan\\frac{Q_z}{\\sqrt{Q_x^2+Q_y^2}},\\quad\\phi_0^B=\\arccos\\frac{Q_y}{\\sqrt{Q_x^2+Q_y^2}} \\end{equation} \\] It should be noticed that this is a theoretical result in (q \\(_z\\) ,q \\(_x\\) ) plane. Diffraction Ewald sphere is not considered here. Thus there is no 'missing wadge' as it always appears in GIWAXS. And a Gaussion profile in \\(\\hat{q}\\) direction is added to make a finite peak width in 2D image plane. In real materials the line shape in \\(\\hat{q}\\) is Lorentizian which depends on strain and crystallite size. Bragg Peaks \u00b6 Although we aim at 2D material in this proposal, a 3D crystal structure is needed to calculate the Bragg peaks. If the position of atoms is described in 2D, we need to assume a lattice constant or d-spacing in z-direction. The single crystal Bragg peaks are calculated from crystal structure file(.cif, POSCAR et. al) where lattice parameters and the positions of atoms in real space are provided. POSCAR File Sn2 O4 1.0 4.7648180450000002 0.0000000000000000 0.0000000000000003 0.0000000000000008 4.7648180450000002 0.0000000000000003 0.0000000000000000 0.0000000000000000 3.2074997700000001 Sn O 2 4 direct 0.5000000000000000 0.5000000000000000 0.5000000000000000 Sn4 + 0.0000000000000000 0.0000000000000000 0.0000000000000000 Sn4 + 0.8059722950000000 0.1940277050000000 0.5000000000000000 O2 - 0.1940277050000000 0.8059722950000000 0.5000000000000000 O2 - 0.3059722950000000 0.3059722950000001 0.0000000000000000 O2 - 0.6940277050000000 0.6940277050000000 0.0000000000000000 O2 - The unit vector in real and reciprocal space are defined as: \\[ \\begin{equation} \\begin{aligned} \\mathbf{a}_1&=(a,0,0),\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\,\\,\\,\\,\\quad\\quad\\quad\\quad \\mathbf{b}_1=\\frac{2\\pi}{V}\\mathbf{a}_2\\times\\mathbf{a}_3\\\\ \\mathbf{a}_2&=(b\\cos\\gamma,b\\sin\\gamma,0),\\quad\\quad\\quad\\quad\\quad\\quad\\,\\,\\,\\quad\\quad\\quad\\quad\\mathbf{b}_2=\\frac{2\\pi}{V}\\mathbf{a}_3\\times\\mathbf{a}_1\\\\ \\mathbf{a}_3&=(c\\cos\\beta,cn_2,c\\sqrt{\\sin^2\\beta+n_2^2}),\\quad\\quad\\quad\\quad\\quad\\quad\\mathbf{b}_3=\\frac{2\\pi}{V}\\mathbf{a}_1\\times\\mathbf{a}_2 \\end{aligned} \\end{equation} \\] where \\((a,b,c)\\) and \\((\\alpha,\\beta,\\gamma)\\) are lattice constants and angles of unit cell, \\[ \\begin{equation} n_2=\\frac{\\cos\\alpha-\\cos\\beta\\cos\\gamma}{\\sin\\gamma} \\end{equation} \\] \\[ \\begin{equation} V= \\mathbf{a}_1\\cdot(\\mathbf{a}_2\\times\\mathbf{a}_3) \\end{equation} \\] We also made a rotation matrix to help adjust the sample orientation if the it is not ideally given by in the crystal structure file: \\[ \\begin{equation} M=\\left(\\begin{array}{ccc} \\mathbf{a}_1\\\\ \\mathbf{a}_2 \\\\ \\mathbf{a}_3 \\end{array}\\right)=\\left(\\begin{array}{ccc} a & 0 & 0\\\\ b\\cos\\gamma & b\\sin\\gamma & 0 \\\\ c\\cos\\beta & c n_2 & c\\sqrt{\\sin^2\\beta+n_2^2} \\end{array}\\right) \\end{equation} \\] \\[ \\begin{equation} \\hat{q},\\,|\\mathbf{q}|,\\,\\Delta E \\end{equation} \\] \\[ \\begin{equation} E=\\sqrt{m^2c^4+p^2c^2} \\end{equation} \\] \\[ \\begin{equation} R_x(\\theta)=\\left(\\begin{array}{ccc} 1 & 0 & 0\\\\ 0 & \\cos\\theta & -\\sin\\theta \\\\ 0 & \\sin\\theta & \\cos\\theta \\end{array}\\right),\\quad R_y(\\theta)=\\left(\\begin{array}{ccc} \\cos\\theta & 0 & -\\sin\\theta\\\\ 0 & 1 & 0 \\\\ \\sin\\theta & 0 & \\cos\\theta \\end{array}\\right) \\end{equation} \\] Multiply Matrix M by \\(R_x(\\theta)\\) or \\(R_y(\\theta)\\) gives the rotated lattice vectors. Position of Bragg peaks with Miller index (hkl): \\[ \\begin{equation} \\mathbf{G}=h\\mathbf{b}_1+k\\mathbf{b}_2+l\\mathbf{b}_3 \\end{equation} \\] Workflow of this program: stateDiagram-v2 CIF --> POSCAR POSCAR: POSCAR POSCAR: Lattice Constants POSCAR: Atom position POSCAR --> Bragg Input1 --> Bragg Input1: Input Input1: (hkl) dimensions Input1: Rotation Bragg: Bragg peak Bragg: Bragg peak postitions in reciprocal space (3D) Bragg --> Intensity Input2 --> Intensity Input2: Input Input2: Peak Broadening parameters Input2: 2D image grid Intensity --> 2d 2d: 2d image display Download the source code. Code Set the parameters Read CIF Simulation Plot import numpy as np import diffraction as diff import matplotlib.pyplot as plt import matplotlib.cm as cm import time as time from matplotlib.widgets import Button import scipy.io from matplotlib.widgets import RangeSlider import scipy.ndimage as ndimage import matplotlib.patheffects as path_effects # use thetax and thetay to adjust initial orientation of the sample thetax = np . pi / 2 * 1 thetay = np . pi / 2 * 0 hkl_dimension = 10 # sigma_theta, if you need a small number for single crystal, input~0.01, # if you need infinity, input~1000 sigma1 = 0.02 # sigma_phi sigma2 = 1000 # sigma_r, use this to tune the peak linewidth sigma3 = 0.01 # settings for imagine plane resolutionx = 300 qxymax = 2.5 qzmax = 3 qzmin = 0 resolutionz = int ( resolutionx / qxymax * qzmax ) gridx , gridz = np . meshgrid ( np . linspace ( - qxymax , qxymax , resolutionx ), np . linspace ( qzmin , qzmax , resolutionz )) # read crystal structure from POSCAR # POSCAR file which can be easily converted from cif on VESTA (fractional coordinate) dirr = '' filename = 'MA2DMF2Pb3I8_Petrov2017' address = dirr + filename + '.vasp' a1 , a2 , a3 , positions = diff . read_poscar ( address ) # example (graphite) Bpeaks , Mqxy , Mqz , I_miller = diff . Braggg_peaks ( a1 , a2 , a3 , positions , thetax , thetay , hkl_dimension ) t1_start = time . process_time () # calculated GIWAXS pattern III = diff . intensity ( gridx , gridz , Bpeaks , sigma1 , sigma2 , sigma3 , hkl_dimension ) t1_stop = time . process_time () print ( 'cpu time =' ) print ( t1_stop - t1_start , 's' ) # make the plot colorbar = 0.5 # upper limit # II1=np.log(III+1) II1 = III fig , ax = plt . subplots ( figsize = ( 14 , 14 )) plt . imshow ( II1 , interpolation = 'nearest' , cmap = cm . jet , origin = 'lower' , extent = [ - qxymax , qxymax , qzmin , qzmax ], vmax = colorbar * II1 . max (), vmin = II1 . min ()) ax . set_xlabel ( 'q$_ {xy} $(1/A)' , fontsize = 16 ) ax . set_ylabel ( 'q$_ {z} $(1/A)' , fontsize = 16 ) ax . set_title ( filename + ' GIWAXS simulation' , fontsize = 16 ) fig . set_size_inches ([ 17 , 10 ])","title":"GIWAXS Simulation"},{"location":"GIWAXS/GIWAXS%20Simulation/#giwaxs-simulation-tool-in-python","text":"Zihan Zhang ( zihan.zhang-1@colorado.edu ) A program for 2D material diffraction simulation is introduced in this work. The sample is considered as crystallites with a Gaussian distribution in orientation in spherical coordinate (r, \\(\\theta\\) , \\(\\phi\\) ). The simulated diffraction pattern is in (q \\(_x\\) , q \\(_{xy}\\) ) plane which is designed to compare with WAXS(wide angle x-ray scattering) measurement. Thus Braggg peaks elongates in a ring pattern from their original positions in reciprocal space. Fig 1. (a) Crystal structure of 2D perovskite; (b) GIWAXS data of PPA; (c) GIWAXS simulation of PPA.","title":"GIWAXS Simulation tool in Python"},{"location":"GIWAXS/GIWAXS%20Simulation/#diffraction-intensity","text":"In reciprocal space, the Gaussian distribution in crystallites orientation results in a rotation for each Bragg peak. If we consider using an area detector to measure the diffraction intensity in q \\(_z\\) q \\(_{x}\\) plane. It is a summation of all Bragg peaks with each of them has the same Gaussian width( \\(\\sigma_\\theta\\) , \\(\\sigma_\\phi\\) ) centered in (q \\(_x\\) , q \\(_y\\) , q \\(_z\\) ): \\[ \\begin{equation} I(q_z,q_{x})=\\sum_{h,k,l}|\\sum_{i} f_i(\\mathbf{Q}) e^{i\\mathbf{Q}\\cdot\\mathbf{r}_n}|^2 e^{-\\frac{1}{2}\\frac{(\\theta^I-\\theta_0^B)^2}{\\sigma_\\theta^2}}e^{-\\frac{1}{2}\\frac{(\\phi^I-\\phi_0^B)^2}{\\sigma_\\phi^2}}e^{-\\frac{1}{2}\\frac{(q^I-q_0^B)^2}{\\sigma_q^2}} \\end{equation} \\] where ( \\(q^I\\) , \\(\\theta^I\\) , \\(\\phi^I\\) ) is the position of image plane(q \\(_x\\) , q \\(_z\\) ) in spherical coordinate. Fig 2. Spherical Coordinate \\[ \\begin{equation} q=\\sqrt{q_z^2+q_{x}^2},\\quad \\theta=\\frac{\\pi}{2}-\\arctan\\frac{q_z}{|q_{x}|}, \\quad \\phi= \\left\\{ \\begin{array}{cc} 0, \\quad x>0\\\\ \\pi,\\quad x<0 \\end{array} \\right. \\end{equation} \\] \\(\\mathbf{Q}\\) is the position of Bragg peaks and (hkl) is Miller index. \\(n\\) indicate the atoms in the unit cell and r \\(_n\\) is the real space position of \\(n\\) th atom in the unit cell. \\[ \\begin{equation} \\mathbf{Q}=h\\mathbf{b}_1+k\\mathbf{b}_2+l\\mathbf{b}_3 \\end{equation} \\] ( \\(q_0^B\\) , \\(\\theta_0^B\\) , \\(\\phi_0^B\\) ) is the position of Bragg peaks in reciprocal space converted to spherical coordinates: \\[ \\begin{equation} q_0^B=|\\mathbf{Q}|,\\quad\\theta_0^B=\\arctan\\frac{Q_z}{\\sqrt{Q_x^2+Q_y^2}},\\quad\\phi_0^B=\\arccos\\frac{Q_y}{\\sqrt{Q_x^2+Q_y^2}} \\end{equation} \\] It should be noticed that this is a theoretical result in (q \\(_z\\) ,q \\(_x\\) ) plane. Diffraction Ewald sphere is not considered here. Thus there is no 'missing wadge' as it always appears in GIWAXS. And a Gaussion profile in \\(\\hat{q}\\) direction is added to make a finite peak width in 2D image plane. In real materials the line shape in \\(\\hat{q}\\) is Lorentizian which depends on strain and crystallite size.","title":"Diffraction Intensity"},{"location":"GIWAXS/GIWAXS%20Simulation/#bragg-peaks","text":"Although we aim at 2D material in this proposal, a 3D crystal structure is needed to calculate the Bragg peaks. If the position of atoms is described in 2D, we need to assume a lattice constant or d-spacing in z-direction. The single crystal Bragg peaks are calculated from crystal structure file(.cif, POSCAR et. al) where lattice parameters and the positions of atoms in real space are provided. POSCAR File Sn2 O4 1.0 4.7648180450000002 0.0000000000000000 0.0000000000000003 0.0000000000000008 4.7648180450000002 0.0000000000000003 0.0000000000000000 0.0000000000000000 3.2074997700000001 Sn O 2 4 direct 0.5000000000000000 0.5000000000000000 0.5000000000000000 Sn4 + 0.0000000000000000 0.0000000000000000 0.0000000000000000 Sn4 + 0.8059722950000000 0.1940277050000000 0.5000000000000000 O2 - 0.1940277050000000 0.8059722950000000 0.5000000000000000 O2 - 0.3059722950000000 0.3059722950000001 0.0000000000000000 O2 - 0.6940277050000000 0.6940277050000000 0.0000000000000000 O2 - The unit vector in real and reciprocal space are defined as: \\[ \\begin{equation} \\begin{aligned} \\mathbf{a}_1&=(a,0,0),\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\,\\,\\,\\,\\quad\\quad\\quad\\quad \\mathbf{b}_1=\\frac{2\\pi}{V}\\mathbf{a}_2\\times\\mathbf{a}_3\\\\ \\mathbf{a}_2&=(b\\cos\\gamma,b\\sin\\gamma,0),\\quad\\quad\\quad\\quad\\quad\\quad\\,\\,\\,\\quad\\quad\\quad\\quad\\mathbf{b}_2=\\frac{2\\pi}{V}\\mathbf{a}_3\\times\\mathbf{a}_1\\\\ \\mathbf{a}_3&=(c\\cos\\beta,cn_2,c\\sqrt{\\sin^2\\beta+n_2^2}),\\quad\\quad\\quad\\quad\\quad\\quad\\mathbf{b}_3=\\frac{2\\pi}{V}\\mathbf{a}_1\\times\\mathbf{a}_2 \\end{aligned} \\end{equation} \\] where \\((a,b,c)\\) and \\((\\alpha,\\beta,\\gamma)\\) are lattice constants and angles of unit cell, \\[ \\begin{equation} n_2=\\frac{\\cos\\alpha-\\cos\\beta\\cos\\gamma}{\\sin\\gamma} \\end{equation} \\] \\[ \\begin{equation} V= \\mathbf{a}_1\\cdot(\\mathbf{a}_2\\times\\mathbf{a}_3) \\end{equation} \\] We also made a rotation matrix to help adjust the sample orientation if the it is not ideally given by in the crystal structure file: \\[ \\begin{equation} M=\\left(\\begin{array}{ccc} \\mathbf{a}_1\\\\ \\mathbf{a}_2 \\\\ \\mathbf{a}_3 \\end{array}\\right)=\\left(\\begin{array}{ccc} a & 0 & 0\\\\ b\\cos\\gamma & b\\sin\\gamma & 0 \\\\ c\\cos\\beta & c n_2 & c\\sqrt{\\sin^2\\beta+n_2^2} \\end{array}\\right) \\end{equation} \\] \\[ \\begin{equation} \\hat{q},\\,|\\mathbf{q}|,\\,\\Delta E \\end{equation} \\] \\[ \\begin{equation} E=\\sqrt{m^2c^4+p^2c^2} \\end{equation} \\] \\[ \\begin{equation} R_x(\\theta)=\\left(\\begin{array}{ccc} 1 & 0 & 0\\\\ 0 & \\cos\\theta & -\\sin\\theta \\\\ 0 & \\sin\\theta & \\cos\\theta \\end{array}\\right),\\quad R_y(\\theta)=\\left(\\begin{array}{ccc} \\cos\\theta & 0 & -\\sin\\theta\\\\ 0 & 1 & 0 \\\\ \\sin\\theta & 0 & \\cos\\theta \\end{array}\\right) \\end{equation} \\] Multiply Matrix M by \\(R_x(\\theta)\\) or \\(R_y(\\theta)\\) gives the rotated lattice vectors. Position of Bragg peaks with Miller index (hkl): \\[ \\begin{equation} \\mathbf{G}=h\\mathbf{b}_1+k\\mathbf{b}_2+l\\mathbf{b}_3 \\end{equation} \\] Workflow of this program: stateDiagram-v2 CIF --> POSCAR POSCAR: POSCAR POSCAR: Lattice Constants POSCAR: Atom position POSCAR --> Bragg Input1 --> Bragg Input1: Input Input1: (hkl) dimensions Input1: Rotation Bragg: Bragg peak Bragg: Bragg peak postitions in reciprocal space (3D) Bragg --> Intensity Input2 --> Intensity Input2: Input Input2: Peak Broadening parameters Input2: 2D image grid Intensity --> 2d 2d: 2d image display Download the source code. Code Set the parameters Read CIF Simulation Plot import numpy as np import diffraction as diff import matplotlib.pyplot as plt import matplotlib.cm as cm import time as time from matplotlib.widgets import Button import scipy.io from matplotlib.widgets import RangeSlider import scipy.ndimage as ndimage import matplotlib.patheffects as path_effects # use thetax and thetay to adjust initial orientation of the sample thetax = np . pi / 2 * 1 thetay = np . pi / 2 * 0 hkl_dimension = 10 # sigma_theta, if you need a small number for single crystal, input~0.01, # if you need infinity, input~1000 sigma1 = 0.02 # sigma_phi sigma2 = 1000 # sigma_r, use this to tune the peak linewidth sigma3 = 0.01 # settings for imagine plane resolutionx = 300 qxymax = 2.5 qzmax = 3 qzmin = 0 resolutionz = int ( resolutionx / qxymax * qzmax ) gridx , gridz = np . meshgrid ( np . linspace ( - qxymax , qxymax , resolutionx ), np . linspace ( qzmin , qzmax , resolutionz )) # read crystal structure from POSCAR # POSCAR file which can be easily converted from cif on VESTA (fractional coordinate) dirr = '' filename = 'MA2DMF2Pb3I8_Petrov2017' address = dirr + filename + '.vasp' a1 , a2 , a3 , positions = diff . read_poscar ( address ) # example (graphite) Bpeaks , Mqxy , Mqz , I_miller = diff . Braggg_peaks ( a1 , a2 , a3 , positions , thetax , thetay , hkl_dimension ) t1_start = time . process_time () # calculated GIWAXS pattern III = diff . intensity ( gridx , gridz , Bpeaks , sigma1 , sigma2 , sigma3 , hkl_dimension ) t1_stop = time . process_time () print ( 'cpu time =' ) print ( t1_stop - t1_start , 's' ) # make the plot colorbar = 0.5 # upper limit # II1=np.log(III+1) II1 = III fig , ax = plt . subplots ( figsize = ( 14 , 14 )) plt . imshow ( II1 , interpolation = 'nearest' , cmap = cm . jet , origin = 'lower' , extent = [ - qxymax , qxymax , qzmin , qzmax ], vmax = colorbar * II1 . max (), vmin = II1 . min ()) ax . set_xlabel ( 'q$_ {xy} $(1/A)' , fontsize = 16 ) ax . set_ylabel ( 'q$_ {z} $(1/A)' , fontsize = 16 ) ax . set_title ( filename + ' GIWAXS simulation' , fontsize = 16 ) fig . set_size_inches ([ 17 , 10 ])","title":"Bragg Peaks"},{"location":"GIWAXS/GIWAXS%20image%20tool/","text":"GIWAXS image tool in Python \u00b6 Zihan Zhang ( zihan.zhang-1@colorado.edu ) This is an example of the GIWAXS class in python. Import libraries, the GIWAXS class is included in GIWAXS.py. Code import numpy as np import pandas as pd import math import matplotlib.pyplot as plt import matplotlib.cm as cm import scipy.io from scipy.optimize import curve_fit import GIWAXS import scipy.misc import os from PIL import Image import tifffile Load experiment data (.tiff file) with the coordinate. And create a GIWAXS object by M=GIWAXS.GIWAXS(...). Code Output # read .tiff file dirr = \"\" filename = \"test_qmap\" path = os . path . join ( dirr , filename ) f = tifffile . imread ( path + '.tiff' ) Giwaxs_data = np . array ( f ) qzmax = np . max ( np . loadtxt ( 'test_qz.txt' )) / 10 qzmin = np . min ( np . loadtxt ( 'test_qz.txt' )) / 10 qxymax = np . max ( np . loadtxt ( 'test_qxy.txt' )) / 10 qxymin = np . min ( np . loadtxt ( 'test_qxy.txt' )) / 10 qz = [ qzmin , qzmax ] qxy = [ qxymin , qxymax ] M = GIWAXS . GIWAXS ( Giwaxs_data , qxy , qz , 'Example' , dirr ) M . switch_qxy () M . switch_qz () M . imshow () print ( 'qz=' , qz ) print ( 'qxy=' , qxy ) qz= -1.8346400457410241 2.8658707336457097 qxy= -2.4817527502473498 2.10232264951378 Then you can use cut() function to resize your GIWAXS image. Code Output M . cut ([ 0 , 2 ],[ 0 , 2 ]) M . rename ( 'image cut example' ) M . cut_imshow () peak_finder() can help you find the peaks in the cut image. Tune neighborhood_size and threshold to improve the performance. You can also print (q \\(_{xy}\\) , q \\(_z\\) ) and q by setting print_peak_position to True Code Output neighborhood_size = 30 threshold = 30 print_peak_position = True colorbar = 0.1 M . cut_imshow () M . peak_finder ( neighborhood_size , threshold , print_peak_position ) Qzint() integrate the selected area and gives the intensity vs q \\(_z\\) . Qxyint() gives intensity vs q \\(_{xy}\\) . Code Output qxy1 = [ 0.3 , 0.4 ] qz1 = [ 0.2 , 0.4 ] M . rename ( 'qzint example' ) M . qzint ( qxy1 , qz1 ) M . qzint_imshow () aglint() integrate the selected sector to get intensity vs q. qp defines the number of points in \\(q\\) . A smooth option is also offered to convolute the curve. Code Output angle = [ - 40 , - 25 ] qrange = [ 0.6 , 0.77 ] smooth1 = False qp = 20 M . aglint ( angle , qrange , qp , smooth = smooth1 , Nsmooth = 10 ) q0 , I0 = M . aglint_imshow ()","title":"GIWAXS image tool"},{"location":"GIWAXS/GIWAXS%20image%20tool/#giwaxs-image-tool-in-python","text":"Zihan Zhang ( zihan.zhang-1@colorado.edu ) This is an example of the GIWAXS class in python. Import libraries, the GIWAXS class is included in GIWAXS.py. Code import numpy as np import pandas as pd import math import matplotlib.pyplot as plt import matplotlib.cm as cm import scipy.io from scipy.optimize import curve_fit import GIWAXS import scipy.misc import os from PIL import Image import tifffile Load experiment data (.tiff file) with the coordinate. And create a GIWAXS object by M=GIWAXS.GIWAXS(...). Code Output # read .tiff file dirr = \"\" filename = \"test_qmap\" path = os . path . join ( dirr , filename ) f = tifffile . imread ( path + '.tiff' ) Giwaxs_data = np . array ( f ) qzmax = np . max ( np . loadtxt ( 'test_qz.txt' )) / 10 qzmin = np . min ( np . loadtxt ( 'test_qz.txt' )) / 10 qxymax = np . max ( np . loadtxt ( 'test_qxy.txt' )) / 10 qxymin = np . min ( np . loadtxt ( 'test_qxy.txt' )) / 10 qz = [ qzmin , qzmax ] qxy = [ qxymin , qxymax ] M = GIWAXS . GIWAXS ( Giwaxs_data , qxy , qz , 'Example' , dirr ) M . switch_qxy () M . switch_qz () M . imshow () print ( 'qz=' , qz ) print ( 'qxy=' , qxy ) qz= -1.8346400457410241 2.8658707336457097 qxy= -2.4817527502473498 2.10232264951378 Then you can use cut() function to resize your GIWAXS image. Code Output M . cut ([ 0 , 2 ],[ 0 , 2 ]) M . rename ( 'image cut example' ) M . cut_imshow () peak_finder() can help you find the peaks in the cut image. Tune neighborhood_size and threshold to improve the performance. You can also print (q \\(_{xy}\\) , q \\(_z\\) ) and q by setting print_peak_position to True Code Output neighborhood_size = 30 threshold = 30 print_peak_position = True colorbar = 0.1 M . cut_imshow () M . peak_finder ( neighborhood_size , threshold , print_peak_position ) Qzint() integrate the selected area and gives the intensity vs q \\(_z\\) . Qxyint() gives intensity vs q \\(_{xy}\\) . Code Output qxy1 = [ 0.3 , 0.4 ] qz1 = [ 0.2 , 0.4 ] M . rename ( 'qzint example' ) M . qzint ( qxy1 , qz1 ) M . qzint_imshow () aglint() integrate the selected sector to get intensity vs q. qp defines the number of points in \\(q\\) . A smooth option is also offered to convolute the curve. Code Output angle = [ - 40 , - 25 ] qrange = [ 0.6 , 0.77 ] smooth1 = False qp = 20 M . aglint ( angle , qrange , qp , smooth = smooth1 , Nsmooth = 10 ) q0 , I0 = M . aglint_imshow ()","title":"GIWAXS image tool in Python"},{"location":"GIWAXS/GIWAXS/","text":"GIWAXS experiment \u00b6","title":"GIWAXS experiment"},{"location":"GIWAXS/GIWAXS/#giwaxs-experiment","text":"","title":"GIWAXS experiment"},{"location":"GIWAXS/intro/","text":"Introduction to GIWAXS \u00b6","title":"Introduction to GIWAXS"},{"location":"GIWAXS/intro/#introduction-to-giwaxs","text":"","title":"Introduction to GIWAXS"},{"location":"RSoXS/Contrast_function/","text":"The contrast of RSoXS is strongly dependent on the dispersion ( \\(\\delta\\) ) and the absorption ( \\(\\beta\\) ) components of the refractive index (n) as represented in the equations below. The refractive index [ \\(n(E)\\) ] at a photon energy \\(E\\) can be calculated using equation: \\[\\begin{equation} \\begin{aligned} n(E)=&1-\\delta(E)+i\\beta(E)\\\\ =&1-\\frac{r_0}{2\\pi}\\lambda^2\\sum_j N_j[f_{1j}(E)+if_{2j}(E)] \\end{aligned} \\label{eq:contrast1} \\end{equation}\\] The contrast function ( \\(C\\) ) can be estimated from equation: \\begin{equation} C\\propto{(\\Delta n)^2}\\propto{(\\Delta\\delta)^2+(\\Delta\\beta)^2} \\label{eq:contrast2} \\end{equation} Where \\(r_0\\) is the classical electron radius, \\(\\lambda\\) is the wavelength of incident X-rays, \\(N_M\\) the number density of an atom ( \\(M\\) ), \\(f_1\\) and \\(f_2\\) are the real and imaginary parts of the complex atomic scattering factor, and the summation is performed for all atoms ( \\(M\\) ). Kramers\u2013Kronig relations: \\begin{equation} \\chi_1(\\omega)=\\frac{1}{\\pi} \\mathcal{P} \\int_{-\\infty}^{\\infty} \\frac{\\omega^{\\prime} \\chi_2\\left(\\omega^{\\prime}\\right)}{\\omega^{\\prime 2}-\\omega^2} d \\omega^{\\prime}+\\frac{\\omega}{\\pi} \\mathcal{P} \\int_{-\\infty}^{\\infty} \\frac{\\chi_2\\left(\\omega^{\\prime}\\right)}{\\omega^{\\prime 2}-\\omega^2} d \\omega^{\\prime} \\end{equation} \\[\\begin{equation} \\chi_2(\\omega)=-\\frac{2}{\\pi} \\mathcal{P} \\int_0^{\\infty} \\frac{\\omega \\chi_1\\left(\\omega^{\\prime}\\right)}{\\omega^{\\prime 2}-\\omega^2} d \\omega^{\\prime}=-\\frac{2 \\omega}{\\pi} \\mathcal{P} \\int_0^{\\infty} \\frac{\\chi_1\\left(\\omega^{\\prime}\\right)}{\\omega^{\\prime 2}-\\omega^2} d \\omega^{\\prime} \\end{equation}\\]","title":"Contrast function"},{"location":"Rigaku/intro/","text":"ConvertRASX \u00b6 Extracts image from Rigaku .rasx format and converts it to .tiff and .jpg Julian Mars ( julian.mars@outlook.com ) Import Defs Path import numpy as np import matplotlib.pyplot as plt from zipfile import ZipFile from PIL import Image from pathlib import Path from glob import glob import io as io def open_rasx ( fname ): \"\"\" Opens rigaku .rasx image files. File structure is as following: .rasx -> zip -root.xml -DataN -ImageX.bin -MesurementConditions0.xml \"\"\" with ZipFile ( fname ) as myzip : with myzip . open ( 'Data0/Image0.bin' ) as myfile : im = np . frombuffer ( myfile . read (), dtype = 'uint32' , ) . reshape ( 385 , 775 ) with myzip . open ( 'Data0/MesurementConditions0.xml' ) as myfile : header = myfile . read () . decode () return im , header def save_tif ( fname , im ): im = Image . fromarray ( im ) im . save ( fname ) folder = Path ( '/Users/zihanzhang/Library/CloudStorage/OneDrive-UCB-O365' ) Convert all Rasx files in the folder: Code for f in glob ( str ( folder ) + '/*.rasx' ): print ( f ) f = Path ( f ) im , header = open_rasx ( f ) #inverse 1st axis im = im [:: - 1 ,:] im = np . log ( im ) plt . imshow ( im ) plt . savefig ( f . with_suffix ( '.jpg' ), dpi = 360 ) plt . show () save_tif ( f . with_suffix ( '.tiff' ), im ) Converted image","title":"Rasx to image file"},{"location":"Rigaku/intro/#convertrasx","text":"Extracts image from Rigaku .rasx format and converts it to .tiff and .jpg Julian Mars ( julian.mars@outlook.com ) Import Defs Path import numpy as np import matplotlib.pyplot as plt from zipfile import ZipFile from PIL import Image from pathlib import Path from glob import glob import io as io def open_rasx ( fname ): \"\"\" Opens rigaku .rasx image files. File structure is as following: .rasx -> zip -root.xml -DataN -ImageX.bin -MesurementConditions0.xml \"\"\" with ZipFile ( fname ) as myzip : with myzip . open ( 'Data0/Image0.bin' ) as myfile : im = np . frombuffer ( myfile . read (), dtype = 'uint32' , ) . reshape ( 385 , 775 ) with myzip . open ( 'Data0/MesurementConditions0.xml' ) as myfile : header = myfile . read () . decode () return im , header def save_tif ( fname , im ): im = Image . fromarray ( im ) im . save ( fname ) folder = Path ( '/Users/zihanzhang/Library/CloudStorage/OneDrive-UCB-O365' ) Convert all Rasx files in the folder: Code for f in glob ( str ( folder ) + '/*.rasx' ): print ( f ) f = Path ( f ) im , header = open_rasx ( f ) #inverse 1st axis im = im [:: - 1 ,:] im = np . log ( im ) plt . imshow ( im ) plt . savefig ( f . with_suffix ( '.jpg' ), dpi = 360 ) plt . show () save_tif ( f . with_suffix ( '.tiff' ), im ) Converted image","title":"ConvertRASX"},{"location":"Tools/salt/","text":"Perovskite Salt Weight Calculator \u00b6 Main Defs ######### user input ######### MA = 1 Cs = 0 FA = 0 Pb = 1 Br = 1.5 I = 1.5 Cl = 0 Molarity = 1 # M volume = 3 # ml ########### b = np . array ([ MA , Cs , FA , Pb , Br , I , Cl ]) give_me_recipe ( b , Molarity * volume ) import numpy as np import itertools import math def solver ( A , b ): return np . transpose ( np . matmul ( np . linalg . inv ( A ), b )) def generate_combinations ( a , b ): nums = [ 1 ] * a + [ 0 ] * ( b - a ) unique_permutations = set ( itertools . permutations ( nums )) result = [ list ( perm ) for perm in unique_permutations ] return result def remove_zero_columns ( A , b ): A = np . array ( A ) b = np . array ( b ) non_zero_indices = np . nonzero ( b )[ 0 ] new_A = A [:, non_zero_indices ] return new_A def replace_ones_with_values ( a , b ): a_index = 0 new_b = [] for value in b : if value == 1 : new_b . append ( a [ a_index ]) a_index += 1 else : new_b . append ( value ) return new_b def compu_reduction ( remove_x , A , b , Chemical_List , Element_List ): n = 0 Chemical_List_remove_index = [] for i in Chemical_List : if remove_x in i : Chemical_List_remove_index . append ( n ) n = n + 1 Chemical_List = np . delete ( Chemical_List , Chemical_List_remove_index , axis = 0 ) A = np . delete ( A , Chemical_List_remove_index , axis = 0 ) n = 0 for i in Element_List : if remove_x in i : A = np . delete ( A , n , axis = 1 ) b = np . delete ( b , n ) n = n + 1 Element_List . remove ( remove_x ) return A , b , Chemical_List , Element_List def give_me_recipe ( b , mmol ): Chemical_List = [ 'MACl' , 'CsCl' , 'FACl' , 'MAI' , 'MABr' , 'CsI' , 'CsBr' , 'FAI' , 'FABr' , 'PbI2' , 'PbBr2' , 'PbCl2' ] Chemical_weight = { 'MACl' : 67.52 , 'CsCl' : 168.36 , 'FACl' : 80.52 , 'MAI' : 158.97 , 'MABr' : 111.97 , 'CsI' : 259.81 , 'CsBr' : 212.81 , 'FAI' : 172.00 , 'FABr' : 125.00 , 'PbI2' : 461.00 , 'PbBr2' : 367.00 , 'PbCl2' : 278.11 } Element_List0 = [ 'MA' , 'Cs' , 'FA' , 'Pb' , 'Br' , 'I' , 'Cl' ] Element_List = [ 'MA' , 'Cs' , 'FA' , 'Pb' , 'Br' , 'I' , 'Cl' ] if abs ( b [ 0 ] + b [ 1 ] + b [ 2 ] + 2 * b [ 3 ] - b [ 4 ] - b [ 5 ] - b [ 6 ]) > 0.0001 : print ( 'The charge is not balanced.' ) # print('Are you kidding me?') else : A = np . array ([[ 1 , 0 , 0 , 0 , 0 , 0 , 1 ], [ 0 , 1 , 0 , 0 , 0 , 0 , 1 ], [ 0 , 0 , 1 , 0 , 0 , 0 , 1 ], [ 1 , 0 , 0 , 0 , 0 , 1 , 0 ], [ 1 , 0 , 0 , 0 , 1 , 0 , 0 ], [ 0 , 1 , 0 , 0 , 0 , 1 , 0 ], [ 0 , 1 , 0 , 0 , 1 , 0 , 0 ], [ 0 , 0 , 1 , 0 , 0 , 1 , 0 ], [ 0 , 0 , 1 , 0 , 1 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 0 , 2 , 0 ], [ 0 , 0 , 0 , 1 , 2 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 0 , 0 , 2 ]]) n = 0 for i in b : if i == 0 : A , b , Chemical_List , Element_List = compu_reduction ( Element_List0 [ n ], A , b , Chemical_List , Element_List ) n = n + 1 A = np . transpose ( A ) b = np . transpose ( b ) cb = generate_combinations ( np . linalg . matrix_rank ( A ), A . shape [ 1 ]) para0 = [] for i in cb : new_A = remove_zero_columns ( A , i ) if np . linalg . matrix_rank ( new_A ) == np . linalg . matrix_rank ( A ): slt = solver ( new_A [: - 1 ], b [: - 1 ]) if np . min ( slt ) >= 0 : para = replace_ones_with_values ( slt , i ) para0 . append ( para ) para0 = np . round ( np . array ( para0 ), 5 ) para0 = np . unique ( para0 , axis = 0 ) recipe_N = 0 for i in para0 : n = 0 recipe_N = recipe_N + 1 print ( 'Recipe #' , recipe_N ) for j in i : if j != 0 : print ( Chemical_List [ n ], j , ',' , np . round ( j * Chemical_weight [ Chemical_List [ n ]] * mmol , 5 ), 'mg' ) n = n + 1 print () Output: Recipe # 1 MABr 1.0 , 335.91 mg PbI2 0.75 , 1037.25 mg PbBr2 0.25 , 275.25 mg Recipe # 2 MAI 1.0 , 476.91 mg PbI2 0.25 , 345.75 mg PbBr2 0.75 , 825.75 mg","title":"Perovskite salt weight calculator"},{"location":"Tools/salt/#perovskite-salt-weight-calculator","text":"Main Defs ######### user input ######### MA = 1 Cs = 0 FA = 0 Pb = 1 Br = 1.5 I = 1.5 Cl = 0 Molarity = 1 # M volume = 3 # ml ########### b = np . array ([ MA , Cs , FA , Pb , Br , I , Cl ]) give_me_recipe ( b , Molarity * volume ) import numpy as np import itertools import math def solver ( A , b ): return np . transpose ( np . matmul ( np . linalg . inv ( A ), b )) def generate_combinations ( a , b ): nums = [ 1 ] * a + [ 0 ] * ( b - a ) unique_permutations = set ( itertools . permutations ( nums )) result = [ list ( perm ) for perm in unique_permutations ] return result def remove_zero_columns ( A , b ): A = np . array ( A ) b = np . array ( b ) non_zero_indices = np . nonzero ( b )[ 0 ] new_A = A [:, non_zero_indices ] return new_A def replace_ones_with_values ( a , b ): a_index = 0 new_b = [] for value in b : if value == 1 : new_b . append ( a [ a_index ]) a_index += 1 else : new_b . append ( value ) return new_b def compu_reduction ( remove_x , A , b , Chemical_List , Element_List ): n = 0 Chemical_List_remove_index = [] for i in Chemical_List : if remove_x in i : Chemical_List_remove_index . append ( n ) n = n + 1 Chemical_List = np . delete ( Chemical_List , Chemical_List_remove_index , axis = 0 ) A = np . delete ( A , Chemical_List_remove_index , axis = 0 ) n = 0 for i in Element_List : if remove_x in i : A = np . delete ( A , n , axis = 1 ) b = np . delete ( b , n ) n = n + 1 Element_List . remove ( remove_x ) return A , b , Chemical_List , Element_List def give_me_recipe ( b , mmol ): Chemical_List = [ 'MACl' , 'CsCl' , 'FACl' , 'MAI' , 'MABr' , 'CsI' , 'CsBr' , 'FAI' , 'FABr' , 'PbI2' , 'PbBr2' , 'PbCl2' ] Chemical_weight = { 'MACl' : 67.52 , 'CsCl' : 168.36 , 'FACl' : 80.52 , 'MAI' : 158.97 , 'MABr' : 111.97 , 'CsI' : 259.81 , 'CsBr' : 212.81 , 'FAI' : 172.00 , 'FABr' : 125.00 , 'PbI2' : 461.00 , 'PbBr2' : 367.00 , 'PbCl2' : 278.11 } Element_List0 = [ 'MA' , 'Cs' , 'FA' , 'Pb' , 'Br' , 'I' , 'Cl' ] Element_List = [ 'MA' , 'Cs' , 'FA' , 'Pb' , 'Br' , 'I' , 'Cl' ] if abs ( b [ 0 ] + b [ 1 ] + b [ 2 ] + 2 * b [ 3 ] - b [ 4 ] - b [ 5 ] - b [ 6 ]) > 0.0001 : print ( 'The charge is not balanced.' ) # print('Are you kidding me?') else : A = np . array ([[ 1 , 0 , 0 , 0 , 0 , 0 , 1 ], [ 0 , 1 , 0 , 0 , 0 , 0 , 1 ], [ 0 , 0 , 1 , 0 , 0 , 0 , 1 ], [ 1 , 0 , 0 , 0 , 0 , 1 , 0 ], [ 1 , 0 , 0 , 0 , 1 , 0 , 0 ], [ 0 , 1 , 0 , 0 , 0 , 1 , 0 ], [ 0 , 1 , 0 , 0 , 1 , 0 , 0 ], [ 0 , 0 , 1 , 0 , 0 , 1 , 0 ], [ 0 , 0 , 1 , 0 , 1 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 0 , 2 , 0 ], [ 0 , 0 , 0 , 1 , 2 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 0 , 0 , 2 ]]) n = 0 for i in b : if i == 0 : A , b , Chemical_List , Element_List = compu_reduction ( Element_List0 [ n ], A , b , Chemical_List , Element_List ) n = n + 1 A = np . transpose ( A ) b = np . transpose ( b ) cb = generate_combinations ( np . linalg . matrix_rank ( A ), A . shape [ 1 ]) para0 = [] for i in cb : new_A = remove_zero_columns ( A , i ) if np . linalg . matrix_rank ( new_A ) == np . linalg . matrix_rank ( A ): slt = solver ( new_A [: - 1 ], b [: - 1 ]) if np . min ( slt ) >= 0 : para = replace_ones_with_values ( slt , i ) para0 . append ( para ) para0 = np . round ( np . array ( para0 ), 5 ) para0 = np . unique ( para0 , axis = 0 ) recipe_N = 0 for i in para0 : n = 0 recipe_N = recipe_N + 1 print ( 'Recipe #' , recipe_N ) for j in i : if j != 0 : print ( Chemical_List [ n ], j , ',' , np . round ( j * Chemical_weight [ Chemical_List [ n ]] * mmol , 5 ), 'mg' ) n = n + 1 print () Output: Recipe # 1 MABr 1.0 , 335.91 mg PbI2 0.75 , 1037.25 mg PbBr2 0.25 , 275.25 mg Recipe # 2 MAI 1.0 , 476.91 mg PbI2 0.25 , 345.75 mg PbBr2 0.75 , 825.75 mg","title":"Perovskite Salt Weight Calculator"},{"location":"tags/","text":"Tags \u00b6 Following is a list of relevant tags:","title":"Tags"},{"location":"tags/#tags","text":"Following is a list of relevant tags:","title":"Tags"}]}